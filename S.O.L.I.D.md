###### tags: `Design Patterns` `S.O.L.I.D` 

## S.O.L.I.D

---

## What is S.O.L.I.D ?

當我們開發了許多的許多程式後，該如何將data和Function妥善安排及設計，這些程式又該如何相互關聯。

S.O.L.I.D則是讓我們透過這些原則設計出 易於理解及維運且能夠量好使用的方法。

---

## S:Single Responsibility Principle(單一職責原則)

---


**定義**:

一個模組應該只對唯一的一個角色負責。

而所謂的角色是指一群會使用該模組的User(或是模組)->思維應該是從該模組會被誰使用出發!

註:區分不同角色所依賴的程式碼，從而減少不同模組間過度依賴

## O:Open-closed Principle(開放封閉原則)

---

**定義**

一個程式的功能在在擴充時是開放的，然而在開放時，不應該修改到原有的程式碼。

**思維**

程式中，元件不應依賴不會直接使用到的東西。

所以在設計架構時，應該根據豪時可能發生變更去分離各項功能，然後將分離的功能組織到元件階層中。

## L:Liskov Substitution Principle(里氏替換原則)
---

**定義**
子類別可以擴充父類別的功能，但不能改變原有功能

子型態必須遵從父型態的行為進行設計

以細節上來說，須滿足以下條件:

1.子型態的先決條件(Preconditions)不應該加強
註:所謂的Prdconditions即程式建立前的必須條件

2.子型態後置條件(Postconditions)不可以變弱

3.子型態必須遵守父型態

註:因為繼承便是依賴性很強的一大特性，請謹慎使用，設計概念為不希望程式碼在做某程度的更新後，行為變得不一致!


## I:Interface segreation Principle(介面隔離原則)
---

**定義**

模組和模組之間，不應該有使用不到的功能被彼此呼叫。

註:從架構上來說，可以透過Interface為類別分類，然後再透過不同角色再分別引用不同功能

## D:Dependency inversion Principle(依賴反向原則)
**定義**
高層模組不應依賴低層模組，它們都應依賴於抽象介面。抽象介面不應該依賴於具體實作，具體實作應依賴抽象介面

註:
低層模組：該模組的實現都是不可分割的原子邏輯層。

高層模組：該模組的業務邏輯多是由低層模組組合而成，如client code。

但在實作上，其實會有非常多高層依賴於低層的情況!

總結:
不是所有時候都需要 100％ 按照 SOLID 原則來設計，這樣只會變得沒完沒了，總會得到一個無法再相依賴於抽象層的模組。

不要過度設計。

